#!/usr/bin/env bash

set -e

function usage() {
    cat >&2 <<EOF
build-bootstrap-config-image.sh out_file [parameters]

Build the configuration image injected into the guestOS
during bootstrap.

The output file needs to be given next. The script will either write a
disk image or tar file as output file (see above).

Following that are the options specifying the configuration to write. Each of
option takes a value given as next argument, and any number of the following
options may be specified:

  --ipv6_address a:b::c/n
    The IPv6 address to assign. Must include netmask in bits (e.g.
    dead:beef::1/64). Overrides all other generation for testing.

  --ic_crypto path
    Injected crypto state. Should point to a directory containing material
    generated by ic-prep. Typically, this is IC_PREP_OUT_PATH/node-X/crypto.

  --ic_state path
    Injected state. Should point to a directory containing a state (with checkpoint)
    to start from. Typically, this is IC_PREP_OUT_PATH/node-X/data/ic_state

  --ic_registry_local_store path
    Injected initial registry state. Should point to a directory containing
    material generated by ic-prep. Typically, this is
    IC_PREP_OUT_PATH/ic_registry_local_store

  --nns_public_key path
    NNS public key file.

  --accounts_ssh_authorized_keys path
    Should point to a directory with files containing the authorized ssh
    keys for specific user accounts on the machine. The name of the
    key designates the name of the account (so, if there is a file
    "PATH/admin" then it is transferred to "~admin/.ssh/authorized_keys" on
    the target). The presently recognized accounts are: backup, readonly and
    admin

  --node_operator_private_key path
    Should point to a file containing a Node Provider private key PEM.
EOF
}

# Arguments:
# - $1 the tar file to build
# - all remaining arguments: parameters to encode into the bootstrap
function build_ic_bootstrap_tar() {
    local OUT_FILE="$1"
    shift

    local IPV6_ADDRESS
    local IC_CRYPTO IC_STATE IC_REGISTRY_LOCAL_STORE
    local NNS_PUBLIC_KEY NODE_OPERATOR_PRIVATE_KEY
    local ACCOUNTS_SSH_AUTHORIZED_KEYS

    while true; do
        if [ $# == 0 ]; then
            break
        fi
        case "$1" in

            --ipv6_address)
                IPV6_ADDRESS="$2"
                ;;
            --ic_crypto)
                IC_CRYPTO="$2"
                ;;
            --ic_state)
                IC_STATE="$2"
                ;;
            --ic_registry_local_store)
                IC_REGISTRY_LOCAL_STORE="$2"
                ;;
            --nns_public_key)
                NNS_PUBLIC_KEY="$2"
                ;;
            --accounts_ssh_authorized_keys)
                ACCOUNTS_SSH_AUTHORIZED_KEYS="$2"
                ;;
            --node_operator_private_key)
                NODE_OPERATOR_PRIVATE_KEY="$2"
                ;;
            *)
                echo "Unrecognized option: $1"
                usage
                exit 1
                break
                ;;
        esac
        shift 2
    done

    local BOOTSTRAP_TMPDIR=$(mktemp -d)

    # todo: switch nns_public_key.pem, node_operator_private_key.pem. and accounts_ssh to use config object
    if [ "${NNS_PUBLIC_KEY}" != "" ]; then
        cp "${NNS_PUBLIC_KEY}" "${BOOTSTRAP_TMPDIR}/nns_public_key.pem"
    fi
    if [ "${NODE_OPERATOR_PRIVATE_KEY}" != "" ]; then
        cp "${NODE_OPERATOR_PRIVATE_KEY}" "${BOOTSTRAP_TMPDIR}/node_operator_private_key.pem"
    fi
    if [ "${ACCOUNTS_SSH_AUTHORIZED_KEYS}" != "" ]; then
        cp -r "${ACCOUNTS_SSH_AUTHORIZED_KEYS}" "${BOOTSTRAP_TMPDIR}/accounts_ssh_authorized_keys"
    fi

    # todo: investigate what to do for...
    if [ "${IC_CRYPTO}" != "" ]; then
        cp -r "${IC_CRYPTO}" "${BOOTSTRAP_TMPDIR}/ic_crypto"
    fi
    if [ "${IC_STATE}" != "" ] && [ -e ${IC_STATE} ]; then
        cp -r "${IC_STATE}" "${BOOTSTRAP_TMPDIR}/ic_state"
    fi
    if [ "${IC_REGISTRY_LOCAL_STORE}" != "" ]; then
        cp -r "${IC_REGISTRY_LOCAL_STORE}" "${BOOTSTRAP_TMPDIR}/ic_registry_local_store"
    fi

    # Create guestos config.json
    echo "* Generating 'config-guestos.json'..."
    /opt/ic/bin/config generate-guestos-config --guestos-ipv6-address "$IPV6_ADDRESS"
    echo "* Copying 'config-guestos.json' to GuestOS config partition..."
    cp /boot/config/config-guestos.json "${BOOTSTRAP_TMPDIR}/config.json"

    tar cf "${OUT_FILE}" \
        --sort=name \
        --owner=root:0 \
        --group=root:0 \
        --mtime="UTC 1970-01-01 00:00:00" \
        -C "${BOOTSTRAP_TMPDIR}" .

    rm -rf "${BOOTSTRAP_TMPDIR}"
}

# Arguments:
# - $1 the disk image to be built
# - all remaining arguments: parameters to encode into the bootstrap

function build_ic_bootstrap_diskimage() {
    local OUT_FILE="$1"
    shift

    local TMPDIR=$(mktemp -d)
    local TAR="${TMPDIR}/ic-bootstrap.tar"
    build_ic_bootstrap_tar "${TAR}" "$@"

    size=$(du --bytes "${TAR}" | awk '{print $1}')
    size=$((2 * size + 1048576))
    echo "image size: $size"
    truncate -s $size "${OUT_FILE}"
    mkfs.vfat -n CONFIG "${OUT_FILE}"
    mcopy -i "${OUT_FILE}" -o "${TAR}" ::

    rm -rf "${TMPDIR}"
}

if [ "$#" -lt 2 ]; then
    usage
    exit 1
fi

build_ic_bootstrap_diskimage "$@"
